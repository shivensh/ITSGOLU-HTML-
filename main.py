import os
import logging
import json
import zipfile
import shutil
from datetime import datetime
from bs4 import BeautifulSoup
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    Application,
    CommandHandler,
    MessageHandler,
    filters,
    CallbackQueryHandler,
    ContextTypes,
)
from dotenv import load_dotenv

# Setup logging
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    level=logging.INFO,
    handlers=[logging.StreamHandler()]
)
logger = logging.getLogger(__name__)

# Load environment variables
load_dotenv()
TOKEN = os.getenv("7775228959:AAFOC1UXl5X4cKGpIr3i1Q2eeCHJjkpcM-Q")
OWNER_ID = int(os.getenv("7740514033", 0))
API_ID = os.getenv("22593658")
API_HASH = os.getenv("511d0fd8542ada4c0aba4e47bd0892ee")
if not TOKEN:
    logger.error("TELEGRAM_BOT_TOKEN not found")
    raise ValueError("TELEGRAM_BOT_TOKEN is required")
if not OWNER_ID:
    logger.warning("OWNER_ID not set; /setpassword command disabled")
if not API_ID:
    logger.warning("API_ID not found; Telegram client features disabled")
if not API_HASH:
    logger.warning("API_HASH not found")

# In-memory storage
USER_SESSIONS = {}  # {user_id: session_token}
USER_HISTORY = {}   # {user_id: [{filename, original_name, file_type}]}
USER_VALUES = {}    # {user_id: {key: value}}
LOGIN_PASSWORD = "easybot123"  # Default password, changeable by owner

# Configuration
CONFIG = {
    "welcome_message": "Welcome! Use /start to begin or /login to sign in.",
    "max_file_size": 50 * 1024 * 1024,  # 50MB
    "max_text_length": 1000,
    "max_history": 5,
    "restrict_message": "Generated by Telegram Bot - All Rights Reserved"
}

# HTML template
HTML_TEMPLATE = """
<html>
<head>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 10px; background: #f0f0f0; }
        .container { display: flex; gap: 10px; }
        .index { width: 150px; background: white; padding: 10px; border-radius: 4px; }
        .index ul { list-style: none; padding: 0; }
        .index li { margin: 5px 0; display: flex; align-items: center; }
        .index a { color: #333; text-decoration: none; max-width: 100px; overflow: hidden; text-overflow: ellipsis; }
        .download { margin-left: 5px; cursor: pointer; }
        .content { flex: 1; background: white; padding: 10px; border-radius: 4px; min-width: 200px; }
        .pdf-viewer { width: 100%; height: 400px; border: none; }
        .nav { margin-top: 10px; }
        .nav button { padding: 8px; margin-right: 5px; cursor: pointer; }
        .values { margin-top: 20px; text-align: right; }
        .values input { width: 100%; max-width: 200px; margin: 5px 0; }
        .restrict { margin-top: 10px; font-size: 14px; color: #666; text-align: right; }
        @media (max-width: 600px) {
            .container { flex-direction: column; }
            .index, .content { width: 100%; }
            .pdf-viewer { height: 250px; }
            .values { text-align: left; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="index">
            <h3>Files</h3>
            <ul id="index-list">{index}</ul>
        </div>
        <div class="content">
            <h1>{title}</h1>
            <p>{content}</p>
            <iframe id="pdf-viewer" class="pdf-viewer" src=""></iframe>
            <div class="nav">
                <button onclick="navigate('prev')">Back</button>
                <button onclick="navigate('next')">Next</button>
                <button onclick="openPDF()">Open PDF</button>
            </div>
            <div class="values">
                <h3>Additional Values</h3>
                {values}
            </div>
            <div class="restrict">{restrict_message}</div>
        </div>
    </div>
    <script>
        let currentIndex = 0;
        const files = {files_json};
        function updateViewer(url) {
            document.getElementById('pdf-viewer').src = url;
        }
        function navigate(direction) {
            if (direction === 'prev' && currentIndex > 0) currentIndex--;
            if (direction === 'next' && currentIndex < files.length - 1) currentIndex++;
            updateViewer(files[currentIndex].url);
            document.querySelectorAll('.index li').forEach((li, i) => {
                li.style.background = i === currentIndex ? '#ddd' : 'none';
            });
        }
        function openPDF() {
            if (files[currentIndex]) window.open(files[currentIndex].url, '_blank');
        }
        document.addEventListener('DOMContentLoaded', () => {
            if (files.length > 0) {
                updateViewer(files[0].url);
                document.querySelector('.index li').style.background = '#ddd';
            }
        });
    </script>
</body>
</html>
"""

async def submitvalues(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle /submitvalues command to store additional values."""
    user_id = update.effective_user.id
    if user_id not in USER_SESSIONS:
        await update.message.reply_text("Please log in: /login <password>")
        return
    if not context.args:
        await update.message.reply_text("Usage: /submitvalues key1=value1 key2=value2")
        return
    values = {}
    for arg in context.args:
        if "=" not in arg:
            await update.message.reply_text(f"Invalid format: {arg}. Use key=value.")
            return
        key, value = arg.split("=", 1)
        if len(key) > 50 or len(value) > 200:
            await update.message.reply_text("Keys/values too long. Max 50/200 characters.")
            return
        values[key] = value.replace("<", "<").replace(">", ">")  # Basic sanitization
    USER_VALUES[user_id] = values
    await update.message.reply_text("Values saved. Generate HTML to include them.")
    logger.info(f"User {user_id} submitted values: {values}")

async def setpassword(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Change login password (owner only)."""
    user_id = update.effective_user.id
    if user_id != OWNER_ID:
        await update.message.reply_text("Only the bot owner can change the password.")
        logger.warning(f"Unauthorized /setpassword attempt by user {user_id}")
        return
    if not context.args:
        await update.message.reply_text("Usage: /setpassword <new_password>")
        return
    new_password = context.args[0].strip()
    if len(new_password) < 6:
        await update.message.reply_text("Password must be at least 6 characters.")
        return
    global LOGIN_PASSWORD
    LOGIN_PASSWORD = new_password
    await update.message.reply_text("Password updated successfully.")
    logger.info(f"Password changed by owner {user_id}")

async def login(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle user login."""
    user_id = update.effective_user.id
    if user_id in USER_SESSIONS:
        await update.message.reply_text("Already logged in. Use /logout to sign out.")
        return
    if not context.args:
        await update.message.reply_text("Usage: /login <password>")
        return
    password = context.args[0]
    if password == LOGIN_PASSWORD:
        USER_SESSIONS[user_id] = "logged_in"
        await update.message.reply_text("Login successful!")
        logger.info(f"User {user_id} logged in")
    else:
        await update.message.reply_text("Incorrect password.")
        logger.warning(f"Failed login for user {user_id}")

async def logout(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle user logout."""
    user_id = update.effective_user.id
    if user_id in USER_SESSIONS:
        del USER_SESSIONS[user_id]
        USER_VALUES.pop(user_id, None)  # Clear values on logout
        await update.message.reply_text("Logged out.")
        logger.info(f"User {user_id} logged out")
    else:
        await update.message.reply_text("Not logged in.")

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Start the bot."""
    user_id = update.effective_user.id
    if user_id not in USER_SESSIONS:
        await update.message.reply_text("Please log in: /login <password>")
        return

    keyboard = [
        [InlineKeyboardButton("Generate HTML", callback_data="generate_html")],
        [InlineKeyboardButton("View Files", callback_data="view_history")],
        [InlineKeyboardButton("Download All", callback_data="download_all")],
        [InlineKeyboardButton("Help", callback_data="help")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(CONFIG["welcome_message"], reply_markup=reply_markup)
    logger.info(f"User {user_id} started bot")

async def generate_html(content: str, title: str, user_id: int) -> str:
    """Generate HTML with file index and additional values."""
    files = USER_HISTORY.get(user_id, [])
    index = "".join(
        f'<li><a href="javascript:void(0)" onclick="updateViewer(\'{f["filename"]}\')">{f["original_name"]}</a>'
        f'<a href="{f["filename"]}" download><span class="download">ðŸ“¥</span></a></li>'
        for f in files
    )
    files_json = json.dumps([{"url": f["filename"], "name": f["original_name"]} for f in files])
    content = content.replace("<", "<").replace(">", ">")  # Basic sanitization
    title = title[:50] if len(title) > 50 else title
    values = USER_VALUES.get(user_id, {})
    values_html = "".join(
        f'<div><label>{k}: </label><input type="text" name="{k}" value="{v}"></div>'
        for k, v in values.items()
    )
    return HTML_TEMPLATE.format(
        title=title,
        content=content,
        index=index,
        files_json=files_json,
        values=values_html,
        restrict_message=CONFIG["restrict_message"]
    )

async def save_to_history(user_id: int, filename: str, original_name: str, file_type: str) -> None:
    """Save file to user history."""
    if user_id not in USER_HISTORY:
        USER_HISTORY[user_id] = []
    USER_HISTORY[user_id].append({"filename": filename, "original_name": original_name, "file_type": file_type})
    if len(USER_HISTORY[user_id]) > CONFIG["max_history"]:
        oldest = USER_HISTORY[user_id].pop(0)
        try:
            os.remove(oldest["filename"])
        except FileNotFoundError:
            logger.warning(f"Could not remove old file: {oldest['filename']}")
    logger.info(f"Saved {file_type} for user {user_id}: {original_name}")

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle text messages."""
    user_id = update.effective_user.id
    if user_id not in USER_SESSIONS:
        await update.message.reply_text("Please log in: /login <password>")
        return

    text = update.message.text
    if not text:
        await update.message.reply_text("Please send some text.")
        return
    if len(text) > CONFIG["max_text_length"]:
        await update.message.reply_text("Text too long. Keep it under 1000 characters.")
        return

    html_content = await generate_html(text, "Generated Page", user_id)
    filename = f"output_{datetime.now().strftime('%Y%m%d_%H%M%S')}.html"
    try:
        with open(filename, "w", encoding="utf-8") as f:
            f.write(html_content)
        await update.message.reply_document(document=open(filename, "rb"), filename=filename)
        await save_to_history(user_id, filename, filename, "html")
        logger.info(f"HTML sent to user {user_id}: {filename}")
    except Exception as e:
        logger.error(f"Error generating HTML: {e}")
        await update.message.reply_text("Error generating HTML.")

async def handle_document(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle document uploads."""
    user_id = update.effective_user.id
    if user_id not in USER_SESSIONS:
        await update.message.reply_text("Please log in: /login <password>")
        return

    document = update.message.document
    if document.file_size > CONFIG["max_file_size"]:
        await update.message.reply_text("File too large. Max 50MB.")
        return

    file_type = None
    if document.mime_type == "text/plain":
        file_type = "text"
    elif document.mime_type == "text/html":
        file_type = "html"
    elif document.mime_type == "application/pdf":
        file_type = "pdf"
    elif document.mime_type in ["video/mp4", "video/mpeg"]:
        file_type = "video"
    else:
        await update.message.reply_text("Please send a .txt, .html, PDF, or video (MP4).")
        return

    try:
        file = await document.get_file()
        file_path = f"media/{user_id}/{document.file_name}"
        os.makedirs(f"media/{user_id}", exist_ok=True)
        await file.download_to_drive(file_path)

        if file_type == "text":
            # Convert .txt to .html
            with open(file_path, "r", encoding="utf-8") as f:
                content = f.read()
            html_content = await generate_html(content, document.file_name, user_id)
            filename = f"converted_{document.file_name.rsplit('.', 1)[0]}.html"
            with open(filename, "w", encoding="utf-8") as f:
                f.write(html_content)
            await update.message.reply_document(document=open(filename, "rb"), filename=filename)
            await save_to_history(user_id, filename, filename, "html")
            logger.info(f"Text file to .html for user {user_id}: {filename}")
        elif file_type == "html":
            # Convert .html to .txt
            with open(file_path, "r", encoding="utf-8") as f:
                html_content = f.read()
            soup = BeautifulSoup(html_content, "html.parser")
            text_content = soup.get_text(separator="\n", strip=True)
            filename = f"converted_{document.file_name.rsplit('.', 1)[0]}.txt"
            with open(filename, "w", encoding="utf-8") as f:
                f.write(text_content)
            await update.message.reply_document(document=open(filename, "rb"), filename=filename)
            await save_to_history(user_id, filename, filename, "txt")
            logger.info(f"HTML file to .txt for user {user_id}: {filename}")
        else:
            # Handle PDF or video
            await save_to_history(user_id, file_path, document.file_name, file_type)
            await update.message.reply_text(f"{file_type.capitalize()} uploaded. Generate HTML to see it.")
            logger.info(f"{file_type.capitalize()} uploaded by user {user_id}: {document.file_name}")
    except Exception as e:
        logger.error(f"Error processing file: {e}")
        await update.message.reply_text("Error processing file.")

async def button_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle button clicks."""
    query = update.callback_query
    await query.answer()
    user_id = query.from_user.id
    if user_id not in USER_SESSIONS:
        await query.message.reply_text("Please log in: /login <password>")
        return

    if query.data == "generate_html":
        await query.message.reply_text("Send some text to generate HTML.")
    elif query.data == "view_history":
        files = USER_HISTORY.get(user_id, [])
        if not files:
            await query.message.reply_text("No files in history.")
            return
        keyboard = [[InlineKeyboardButton(f"{f['original_name']} ({f['file_type']})", callback_data=f"file_{i}")]
                   for i, f in enumerate(files)]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.message.reply_text("Your files:", reply_markup=reply_markup)
    elif query.data.startswith("file_"):
        index = int(query.data.split("_")[1])
        files = USER_HISTORY.get(user_id, [])
        if 0 <= index < len(files):
            file_path = files[index]["filename"]
            try:
                await query.message.reply_document(
                    document=open(file_path, "rb"),
                    filename=files[index]["original_name"]
                )
                logger.info(f"File sent to user {user_id}: {files[index]['original_name']}")
            except FileNotFoundError:
                await query.message.reply_text("File not found.")
                logger.warning(f"File not found: {file_path}")
        else:
            await query.message.reply_text("Invalid file selection.")
    elif query.data == "download_all":
        files = USER_HISTORY.get(user_id, [])
        if not files:
            await query.message.reply_text("No files to download.")
            return
        zip_filename = f"files_{user_id}.zip"
        try:
            os.makedirs("temp", exist_ok=True)
            with zipfile.ZipFile(f"temp/{zip_filename}", "w", zipfile.ZIP_DEFLATED) as zf:
                for f in files:
                    try:
                        zf.write(f["filename"], f["original_name"])
                    except FileNotFoundError:
                        logger.warning(f"Could not include file in ZIP: {f['filename']}")
            await query.message.reply_document(
                document=open(f"temp/{zip_filename}", "rb"),
                filename=zip_filename
            )
            logger.info(f"ZIP sent to user {user_id}")
        except Exception as e:
            logger.error(f"Error creating ZIP: {e}")
            await query.message.reply_text("Error creating ZIP file.")
        finally:
            shutil.rmtree("temp", ignore_errors=True)
    elif query.data == "help":
        help_text = (
            "/start - Start bot\n"
            "/login <password> - Log in\n"
            "/logout - Log out\n"
            "/setpassword <new_password> - Change password (owner only)\n"
            "/submitvalues key=value - Add values to HTML\n"
            "Send text to generate HTML\n"
            "Upload .txt (to HTML), .html (to .txt), PDF, or video (MP4)\n"
            "Use buttons to generate HTML or view files"
        )
        await query.message.reply_text(help_text)
        logger.info(f"Help requested by user {user_id}")

async def error_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle errors."""
    logger.error(f"Error: {context.error}")
    if update and update.message:
        await update.message.reply_text("Something went wrong. Try again.")

def main() -> None:
    """Run the bot."""
    try:
        app = Application.builder().token(TOKEN).build()
        app.add_handler(CommandHandler("start", start))
        app.add_handler(CommandHandler("login", login))
        app.add_handler(CommandHandler("logout", logout))
        app.add_handler(CommandHandler("setpassword", setpassword))
        app.add_handler(CommandHandler("submitvalues", submitvalues))
        app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))
        app.add_handler(MessageHandler(filters.Document.ALL, handle_document))
        app.add_handler(CallbackQueryHandler(button_callback))
        app.add_handler(error_handler)
        logger.info("Bot starting")
        app.run_polling(allowed_updates=Update.ALL_TYPES)
    except Exception as e:
        logger.error(f"Bot failed to start: {e}")
        raise

if __name__ == "__main__":
    main()
